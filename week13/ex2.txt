'Detection and recovery' approach lets deadlocks happen, and then an attempt is made to recover from them. This approach is good, since it only does work when the deadlock occurred, thus it does not reduce overall OS performance. However, both detection and recovery are pretty complex operations. Moreover, there are no perfect solution for recovery - some resources are not preemptable, which makes it impossible to simply take away it from the process. Rollback recovery requires constant backups to be made, which both loads the permanent memory and involves making difficult decision of when to do a backup. Killing a process is not a desired solution either.

'Dynamic avoidance' approach tries to dynamically analyze the situation and carefully allocate resources to avoid deadlocks. One of the pros of this approach is that OS would not interfere with the processes and unexpectedly kill them / rollback their state / etc. However, this approach requires a lot of extra information to be known - namely, when and how many resources each process may request. In theory, this information can be approximated quite well, but this will require too much computing power. In addition, the algorithms that can guarantee that deadlock will not occur are extremely complex, and will greatly reduce performance of the scheduler.

'Prevention' approach's idea is to somehow remove a condition that is needed for a deadlock to happen. This approach is great, since in general it does not affect schedulerâ€™s performance too badly. One idea is to avoid giving resources unless absolutely necessary, but this idea is pretty vague, and does not have any formal requirements to be met, and thus is difficult to implement. Another idea is for processes to say, which resources they may need. This idea is also quite hard to implement, and moreover, it will put strict limitations on the system's capabilities, especially in case of interactive systems. The third idea is to use virtualization of resources - indeed pretty powerful solution, but unfortunately is not possible for all kind of resources. The last idea is to limit each process to having only 1 resource at a time. This approach, again, can introduce some limitations in the system.
